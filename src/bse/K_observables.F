!
! License-Identifier: GPL
!
! Copyright (C) 2021 The Yambo Team
!
! Authors (see AUTHORS file for details): AM DS
!
subroutine K_observables( W )
 !
#if defined _SLEPC && !defined _NL
 use BS_solvers,   ONLY:run_Slepc
#endif
 use drivers,      ONLY:l_rpa_IP,l_col_cut
 use frequency,    ONLY:w_samp
 use X_m,          ONLY:global_gauge
 use BS_solvers,   ONLY:run_Haydock,run_inversion,run_Diago,BSS_mode,l_resp_can_be_extended,&
&                       l_abs_prop_chi_bse,l_eels_can_be_computed,l_eels_from_inversion
 use BS,           ONLY:BS_dip_size,l_BS_anomalous_Hall,l_BS_abs,l_BS_jdos,l_BS_trace,BSE_prop,&
&                       l_BS_esort,l_BS_kerr,l_BS_magnons,l_BS_dichroism,l_BS_anomalous_Hall,l_BS_photolum,&
&                       l_BS_optics,BS_dip_size,l_BS_magnons,l_BS_photolum,l_BS_kerr_asymm,BSE_mode,BSE_L_kind
 use parser_m,     ONLY:parser
 use stderr,       ONLY:STRING_match
 use electrons,    ONLY:levels,n_sp_pol,n_spin
 !
 implicit none
 !
 type(w_samp)   :: W
 !
 logical, external :: EPS_check
 !
 ! Work space
 !
 type(levels)  :: Ken
 character(2)  :: ordering
 logical       :: l_flag
 !
 ! What...
 !=========
 l_BS_abs       = STRING_match(BSE_prop,'abs')
 l_BS_jdos      = STRING_match(BSE_prop,'jdos')
 l_BS_dichroism = STRING_match(BSE_prop,'dich')
 l_BS_kerr      = STRING_match(BSE_prop,'kerr')
 l_BS_photolum  = STRING_match(BSE_prop,'photolum')
 l_BS_magnons   = STRING_match(BSE_prop,'magn') .and.n_spin>1
 l_BS_kerr_asymm= STRING_match(BSE_prop,'asymm') .and. l_BS_kerr
 l_BS_anomalous_Hall = STRING_match(BSE_prop,'anHall') .and. l_BS_kerr
 !
 ! How ...
 !---------
 l_BS_esort     = STRING_match(BSE_prop,'esrt')
 !
 ! How to treat dipoles...
 !------------------------
 l_BS_trace     = STRING_match(BSE_prop,'trace')
 !
 ! Consequences which overwrites the kernel_init definitions...
 !--------------------------------------------------------------
 if (l_BS_magnons.and.n_sp_pol==2) then
   l_BS_abs    = .false.
   l_BS_kerr   = .false.
   l_BS_trace  = .false.
   call warning(" n_sp_pol=2 and magnons requested. Spin flip BSE only is computed")
 endif
 if (l_BS_kerr) then
   if(.not.l_BS_anomalous_Hall) call parser('AnHall',l_BS_anomalous_Hall)
   BS_dip_size=2
   l_BS_abs=.TRUE.
 endif
 if (l_BS_photolum) global_gauge="velocity"
 if ((l_BS_photolum.or.l_BS_kerr).and.l_BS_trace) then
   call warning(" Trace not compatible with kerr or pl. Switching it off")
   l_BS_trace  = .false.
 endif
 if (l_BS_dichroism.and..not.l_BS_trace) then
   BS_dip_size=2
   call warning(" Natural dichroism without trace")
 !  NB: in the case without trace the quadripolar terms should be taken into account,
 !  With trace these terms average to zero
 !  call warning(" Trace is automatically switched on with dichroism")
 !  l_BS_trace=.true.
 endif
 !
 if (l_BS_trace   ) BS_dip_size = 3
 if (l_BS_trace .and. .not.l_rpa_IP) call error(" trace coded only at the IP level")
 !
 l_BS_optics=l_BS_abs.or.l_BS_kerr.or.l_BS_dichroism.or.l_BS_photolum
 !
 ! Now fix BSE_prop string
 !
 BSE_prop=""
 if(l_BS_abs)            BSE_prop=trim(BSE_prop)//' abs'
 if(l_BS_jdos)           BSE_prop=trim(BSE_prop)//' jdos'
 if(l_BS_dichroism)      BSE_prop=trim(BSE_prop)//' dich'
 if(l_BS_kerr)           BSE_prop=trim(BSE_prop)//' kerr'
 if(l_BS_kerr_asymm)     BSE_prop=trim(BSE_prop)//' asymm'
 if(l_BS_anomalous_Hall) BSE_prop=trim(BSE_prop)//' anHall'
 if(l_BS_photolum)       BSE_prop=trim(BSE_prop)//' photolum'
 if(l_BS_magnons)        BSE_prop=trim(BSE_prop)//' magn'
 if(l_BS_esort)          BSE_prop=trim(BSE_prop)//' esrt'
 if(l_BS_trace)          BSE_prop=trim(BSE_prop)//' trace'
 !
 ! Solver Logicals
 !=================
 run_Diago     = STRING_match(BSS_mode,'d')
 run_Haydock   = STRING_match(BSS_mode,'h')
 run_inversion = STRING_match(BSS_mode,'i')
#if defined _SLEPC && !defined _NL
 run_Slepc     = STRING_match(BSS_mode,'s')
#endif
 if (l_BS_photolum.and.run_Haydock) then
   call warning('PL currently implemented only using the diagonalization/inversion solver')
   run_Haydock  =.false.
 endif
 if (run_Haydock.and.allocated(Ken%W)) then
   call warning('K with QP widths not supported in the Haydock solver')
   run_Haydock=.false.
 endif
 !
 if(.not.any((/trim(global_gauge)=="velocity".or.trim(global_gauge)=="length"/)) ) then
   call warning(" Not a valid gauge in input. Switching to length gauge")
   global_gauge="length"
 endif
 !
 ! Is absorption (alpha or epsilon) proportional to chi
 !===================================
 !
 ! * In 3D Alpha and epsilon are proporitonal to Lbar
 !
 ! * In 2D, 1D, and 0D Alpha is proportional to L(low_dim), where
 !   L(low_dim)=Lfull=Lbar in the V-> infinity volume
 !
 !   - If the cut-off is not used Lbar is a better approximation to L(low_dim)
 !     e.g. same situation of the 3D case
 !
 !   - If the cut-off is used Lfull is probably a better approximation to L(low_dim),
 !     e.g. opposite situation of the 3D case
 !
 ! Thus, overall, only without the coulomb cutoff Alpha il proporional to Lbar,
 ! e.g. it is proportional to epsilon. This is important without cut-off only
 !
 if (       l_col_cut) l_abs_prop_chi_bse=STRING_match(BSE_L_kind,"full")
 if ( .not. l_col_cut) l_abs_prop_chi_bse=STRING_match(BSE_L_kind,"bar")
 !
 ! However in general the difference with the coulomb cutoff is expected to be tiny.
 ! Advanced user can impose to change behaviour
 call parser('ImposeAlphaChiBar',l_flag)
 if (l_flag.and.l_col_cut) l_abs_prop_chi_bse=STRING_match(BSE_L_kind,"bar")
 !
 ! Check if eels can be evaluated
 if (     trim(BSE_mode)=='resonant' ) ordering='r'
 if (.not.trim(BSE_mode)=='resonant' ) ordering='R'
 l_resp_can_be_extended=EPS_check(W%p,W%n_freqs,.TRUE.,ordering)
 !
 ! Either I'm forced to get the epsilon from extension + inversion
 ! or I want to get the epsilon from extension + inversion
 ! to account of G=0 term in  coupling mode
 ! Not needed if already in coupling mode
 ! Not possible with slepc
 l_eels_from_inversion= (l_abs_prop_chi_bse .or. .not.trim(BSE_mode)=="coupling")
 ! Here I'm ignoring the logical l_resp_can_be_inverted
 !l_eels_from_inversion=l_eels_from_inversion .and. .not.l_resp_can_be_extended
 !
 ! If I cannot get the eels from the inversion and I'm in Lbar case I'm in troubles
 l_eels_can_be_computed = l_eels_from_inversion .or. .not.l_abs_prop_chi_bse
 !
 if (.not.l_eels_can_be_computed) call warning("EELs evaluation switched-off")
 !
end subroutine
