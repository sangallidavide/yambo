!
! License-Identifier: GPL
!
! Copyright (C) 2006 The Yambo Team
!
! Authors (see AUTHORS file for details): AM DS AF
!
module wave_func
 !
 use pars,           ONLY:SP,schlen
 !
#include <dev_defs.h>
#include <memory.h>
#include <yambo_wfs.h>
 !
 type WAVEs 
   integer              :: b(2)      ! band range 
   integer              :: k(2)      ! k range
   integer              :: sp_pol(2) ! sp_pol_range
   integer              :: N         ! states 
   character(1)         :: space
   WF_RSPACE(SP), allocatable :: r(:,:,:)
   complex(SP),   allocatable :: c(:,:,:)
   integer    ,   allocatable :: index(:,:,:)
   logical    ,   allocatable :: state(:,:,:)
   logical                    :: to_load = .TRUE.
   WF_RSPACE(SP), allocatable DEV_ATTR :: r_d(:,:,:)
   complex(SP),   allocatable DEV_ATTR :: c_d(:,:,:)
 end type WAVEs
 !
 ! Buffered WFs
 !
 type (WAVEs), save :: WF_buffer
 logical            :: WF_buffered_IO
 !
 ! Actual WFs
 !
 type (WAVEs), save, target :: WF
 !
 ! Real components ?
 !
 logical                :: real_wavefunctions
 !
 ! Using two shifted sets of WFs
 !
 logical                :: WF_in_loop
 logical                :: WF_load_bz
 logical                :: WF_shifted_grids
 !
 ! Bands block size
 !
 integer, allocatable   :: wf_frag_id(:,:,:)
 integer                :: wf_nb_io
 integer                :: wf_nb_io_groups
 !
 integer                :: wf_nb_to_load
 integer, allocatable   :: wf_b_indx(:)   ! given ib_to_load=1,wf_nb_to_load returns the band index
 !
 ! Max Num. of COMPONENTS
 !
 integer                :: wf_ncx
 !
 ! Max Num. of G-VECTORS for the WFs maxval(wf_igk) > wf_ncx
 !
 integer                :: wf_ng          ! For WFs in the    IBZ
 integer                :: wf_ng_1st_BZ   ! For WFs in the 1st BZ
 integer                :: wf_ng_overlaps ! For WFs shifted used by the overlaps
 integer                :: cutoff_ng      ! For G-vectors used in cutoff (if read, may be different from wf_ng)
 !
 ! Wave function derivatives
 !
 complex(SP), allocatable :: wf_x(:,:,:)
 complex(SP), allocatable :: wf_y(:,:,:)
 complex(SP), allocatable :: wf_z(:,:,:)
 !
 ! Parallel wave-function distribution
 !
 logical,    allocatable:: states_to_load(:,:,:) 
 !
 ! Num. of COMPONENTS at each k
 !
 integer,    allocatable:: wf_nc_k(:)
 !
 ! Tho map to reduce fft_size
 !
 real(SP)               :: rho_map_thresh
 integer                :: rho_map_size
 integer,    allocatable:: rho_map(:)
 integer,    allocatable:: rho_map_inv(:)
 !
 ! Table correspondance G-vec <-> Components: G_ic = wf_igk(ic,ik)
 !
 integer,    allocatable:: wf_igk(:,:)
 integer,    allocatable DEV_ATTR :: wf_igk_d(:,:)
 logical                :: wf_norm_test
 !
 character(schlen)  :: WF_path(4)
 !
 interface
   !
   integer function io_WF_old(ID,wf_old)
     use pars,       ONLY: SP
     integer            :: ID
     real(SP), optional :: wf_old(:,:,:,:)
   end function io_WF_old
   !
   integer function io_WF(ID,wf,wf_d,ipath,keep_fragments_open)
     use pars,       ONLY: SP
     integer, intent(in)           :: ID
     integer, optional, intent(in) :: ipath
     logical, optional, intent(in) :: keep_fragments_open
     complex(SP), optional :: wf(:,:,:)
     complex(SP), optional DEV_ATTR :: wf_d(:,:,:)
   end function io_WF
   !
   integer function io_WF_frag(ID_frag,wf,wf_d)
     use pars,       ONLY: SP
     integer, intent(in) :: ID_frag
     complex(SP), optional  :: wf(:,:,:)
     complex(SP), optional DEV_ATTR :: wf_d(:,:,:)
   end function io_WF_frag
   !
   function WF_symm(ifft,isc)
     use pars,        ONLY: SP
     use electrons,   ONLY: n_spinor
     integer             :: ifft,isc(4)
     complex(SP),dimension(n_spinor) :: WF_symm
   end function
   !
#if defined _CUDA
   function WF_symm_gpu(ifft,isc)
     use pars,        ONLY: SP
     use electrons,   ONLY: n_spinor
     integer             :: ifft,isc(4)
     complex(SP),dimension(n_spinor) DEV_ATTR :: WF_symm_gpu
   end function
#endif
   !
 end interface 
 !
 contains
   !
   subroutine WF_copy(WF_in,WF_out)
     use electrons,  ONLY: n_spinor
     type(WAVEs):: WF_in,WF_out
     YAMBO_ALLOC(WF_out%index,(WF_in%b(1):WF_in%b(2),WF_in%k(1):WF_in%k(2),WF_in%sp_pol(1):WF_in%sp_pol(2)))
     WF_out%b      = WF_in%b
     WF_out%k      = WF_in%k
     WF_out%sp_pol = WF_in%sp_pol
     WF_out%N      = WF_in%N
     WF_out%space  = WF_in%space
     WF_out%to_load= WF_in%to_load
     WF_out%index  = WF_in%index
     !
     if (allocated(WF_in%c)) then
       YAMBO_ALLOC(WF_out%c,(size(WF_in%c(:,1,1)),n_spinor,WF_in%N))
       WF_out%c    = WF_in%c
     endif
     if (allocated(WF_in%c_d)) then
       YAMBO_ALLOC_SOURCE(WF_out%c_d,WF_in%c)
     endif
     if (allocated(WF_in%r)) then
       YAMBO_ALLOC(WF_out%r,(size(WF_in%r(:,1,1)),n_spinor,WF_in%N))
       WF_out%r    = WF_in%r
     endif
     if (allocated(WF_in%r_d)) then
       YAMBO_ALLOC_SOURCE(WF_out%r_d,WF_in%r)
     endif
   end subroutine
   !
   subroutine WF_derivative_alloc(cart_direction)
     use pars,     ONLY : cZERO
     use FFT_m,    ONLY : fft_size
     use electrons,ONLY : n_spinor
     logical  :: cart_direction(3)
     !
     if(cart_direction(1)) then
       YAMBO_ALLOC(wf_x,(fft_size,n_spinor,WF%N))
       wf_x=cZERO
     endif
     if(cart_direction(2)) then
       YAMBO_ALLOC(wf_y,(fft_size,n_spinor,WF%N))
       wf_y=cZERO
     endif
     if(cart_direction(3)) then
       YAMBO_ALLOC(wf_z,(fft_size,n_spinor,WF%N))
       wf_z=cZERO
     endif
   end subroutine
   !
   subroutine WF_derivative_free()
     !
     YAMBO_FREE(wf_x)
     YAMBO_FREE(wf_y)
     YAMBO_FREE(wf_z)
     !
   end subroutine
   !
end module
