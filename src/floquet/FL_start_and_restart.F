!
!
!        Copyright (C) 2000-2021 the YAMBO team
!              http://www.yambo-code.org
!
! Authors (see AUTHORS file for details): AM CA IA
! 
! This file is distributed under the terms of the GNU 
! General Public License. You can redistribute it and/or 
! modify it under the terms of the GNU General Public 
! License as published by the Free Software Foundation; 
! either version 2, or (at your option) any later version.
!
! This program is distributed in the hope that it will 
! be useful, but WITHOUT ANY WARRANTY; without even the 
! implied warranty of MERCHANTABILITY or FITNESS FOR A 
! PARTICULAR PURPOSE.  See the GNU General Public License 
! for more details.
!
! You should have received a copy of the GNU General Public 
! License along with this program; if not, write to the Free 
! Software Foundation, Inc., 59 Temple Place - Suite 330,Boston, 
! MA 02111-1307, USA or visit http://www.gnu.org/copyleft/gpl.txt.
!
subroutine FL_start_and_restart(E,k,Dip)
 !
 ! This subroutine initialize some variables and 
 ! restart from a previous NL calculation
 !
 ! [1] Initialize the Vbands and potentials
 ! [2] Build Ho
 ! [3] RESTART from a previous run
 ! [4] Initialize the bare Hartree and XC
 ! [5] Initialize the fields
 !
 use pars,           ONLY:cZERO,rZERO,cONE,SP
 use com,            ONLY:msg
 use electrons,      ONLY:levels,n_sp_pol
 use real_time,      ONLY:rho_reference
 use R_lattice,      ONLY:bz_samp
 use X_m,            ONLY:X_t
 use DIPOLES,        ONLY:DIPOLE_t
 use hamiltonian,    ONLY:V_hartree_sc,V_xc_sc,H_nl_sc,rho_n
 use X_m,            ONLY:X_t 
 use xc_functionals, ONLY:V_xc,XC_potential_driver
 use QP_m,           ONLY:QP_nk
 use global_XC,      ONLY:WF_xc_functional,WF_kind
 use fields,         ONLY:A_tot,A_ext,A_vecpot_reset
 use parallel_m,     ONLY:master_cpu
 use nl_optics,      ONLY:Correlation,IPA,E_full,full_rho,V_bands,TDDFT,n_runs_todo,NL_LRC_alpha,NL_bands, &
&                         V_xc_0,NL_initial_P,l_use_DIPOLES,n_runs,runs_done,JGM,E_xc_0,I_relax,l_use_DIPOLES, &
&                         VAL_BANDS,l_eval_CURRENT,NL_initial_J,NL_P
 use fl_optics,      ONLY:max_fl_mode,FL_QE,FL_QE_hist,FL_Ho_lift_degeneracy,n_tot_fl_modes,FL_deg_thrs,FL_deg_lift
 use IO_int,         ONLY:io_control
 use IO_m,           ONLY:OP_RD_CL,NONE,file_is_present,VERIFY
 use parallel_int,   ONLY:PP_redux_wait
 use stderr,         ONLY:intc
 use collision_ext,  ONLY:COLLISIONS_have_HARTREE
 !
#include<y_memory.h>
 !
 type(levels)      :: E
 type(bz_samp)     :: k
 type(DIPOLE_t)    :: Dip
 !type(X_t)         :: X
 !
 ! Working space
 !
 integer :: i1,i2,ib,i_f,i_k,i_sp,i_fl,i1_fks,i2_fks,i_sp_pol
 integer :: ID,io_Floquet
 integer, external::io_FL
 logical  :: l_lifted
 !
 !
 ! Initialize the Gf and potentials
 !==================================
 if(allocated(rho_reference))   rho_reference=rZERO
 if(allocated(full_rho))        full_rho    =rZERO
 if(allocated(V_xc_sc))         V_xc_sc     =rZERO
 if(allocated(V_hartree_sc))    V_hartree_sc=rZERO
 H_nl_sc=cZERO
 I_relax=cZERO
 V_bands=cZERO
 !
 if(NL_bands(2)<=maxval(E%nbf).or.NL_bands(1)>minval(E%nbf)) &
     & call error(" Wrong bands range!")
 !
 forall(i1=1:maxval(E%nbf)) V_bands(i1,i1,:,:)=cONE
 !
 if(Correlation/=IPA.and..not.COLLISIONS_have_HARTREE) then
   !  
   call NL_build_valence_bands(E,V_bands,VAL_BANDS,NL_bands(1))
   call el_density_vbands(E,k,rho_reference,VAL_BANDS)
   !
 endif
 !
 ! Fields
 !=====================
 call A_vecpot_reset(A_tot)
 call A_vecpot_reset(A_ext)
 !
 ! Apply QP Corrections
 ! ====================
 do ib=NL_bands(1),NL_bands(2)
   E_full(ib,1:QP_nk,1:n_sp_pol)=E%E(ib,1:QP_nk,1:n_sp_pol)
 enddo
 !
 do ib=1,NL_bands(1)-1
   E_full(ib,1:QP_nk,1:n_sp_pol)=E_full(ib,1:QP_nk,1:n_sp_pol) &
& -E_full(NL_bands(1),1:QP_nk,1:n_sp_pol)+E%E(NL_bands(1),1:QP_nk,1:n_sp_pol)
 enddo
 !
 ! Lift degeneracy in Ho
 ! =====================
 !
 FL_Ho_lift_degeneracy = 0._SP
 l_lifted = .false.
 !
 do i_sp = 1,n_sp_pol
   do i_k = 1,QP_nk
     do i1=NL_bands(1),NL_bands(2)
       do i2=i1+1,NL_bands(2)
         !
         if (abs(E%E(i1,i_k,i_sp)-E%E(i2,i_k,i_sp)) < FL_deg_thrs) then
           !
           l_lifted = .true.
           !
           do i_fl=1,n_tot_fl_modes
             !
             i1_fks = i_fl + (i1-1)*n_tot_fl_modes
             FL_Ho_lift_degeneracy(i1_fks,i_k,i_sp) = &
            &FL_Ho_lift_degeneracy(i1_fks,i_k,i_sp) -1._SP*FL_deg_lift
             i2_fks = i_fl + (i2-1)*n_tot_fl_modes
             FL_Ho_lift_degeneracy(i2_fks,i_k,i_sp) = &
            &FL_Ho_lift_degeneracy(i2_fks,i_k,i_sp) +1._SP*FL_deg_lift
             !
           enddo 
           !
         end if
         !
       enddo
     enddo
   enddo
 enddo
 !
 if (l_lifted) call warning(' Degeneracies in the KS band structure were lifted')
 !
 ! Initialize Quasi-energies
 ! =========================
 !
 FL_QE = E%E(1:NL_bands(2),1:QP_nk,1:n_sp_pol)
 FL_QE_hist = cZERO
 !
 !
 ! Evaluate Initial Polarization 
 ! ====================================
 !
if(.not.l_use_DIPOLES) then
  call POLARIZATION_output(E,k,Dip)
endif
 !
call DIP_polarization(E,k,V_bands,NL_initial_P(4:6))
 !
if(.not.l_use_DIPOLES) then
  !   
  ! This subroutine update also the Sm1_plus,Sm1_minus and All_S_det matrices
  do i_sp_pol=1,n_sp_pol
    call Berry_Polarization_NEQ(E,k,i_sp_pol,V_bands(:,:E%nbf(i_sp_pol),:,i_sp_pol),NL_initial_P(1:3))
  enddo
  !
else
  NL_initial_P(1:3)=NL_initial_P(4:6)
endif
 !
 ! Restart
 ! ====================================
 YAMBO_ALLOC(runs_done,(n_runs))
 !
 runs_done=.false.
 !
 if(master_cpu) then
   !      
   call io_control(ACTION=OP_RD_CL,COM=NONE,SEC=(/1/),MODE=VERIFY,ID=ID)
   io_Floquet=io_FL(ID)
   !
   if(io_Floquet==0) then
     do i_f=1,n_runs
        if(file_is_present('Floquet_fragment_'//intc(i_f))) runs_done(i_f)=.true.
     enddo                                                                    
    endif
    !
 endif
 !
 call PP_redux_wait(runs_done,imode=3)
 !
 n_runs_todo=n_runs-count(runs_done)
 if(n_runs_todo/=n_runs) call msg('s','RESTART, remaining frequencies/angles ',n_runs_todo)
 !
end subroutine FL_start_and_restart
